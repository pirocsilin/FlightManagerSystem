AdapterFMS
==========
Модуль для работы с планом полета 

Интеграция
---------  
Для выполнения запросов к базе данных (БД) необходимо использовать модуль Adapter (Адаптер), который добавляется в корневой cmake файл проекта включением подкаталога */Adapter*: 

```
    add_subdirectory(Adapter)
```
и связывается с исполняемым файлом исходного проекта как библиотека: 
```
    target_link_libraries(${PROJECT_NAME} Adapter) 
```
После включения модуля, можно использовать класс *ControllerFlightPlan* и его методы для отправки и получения запросов из локальной базы данных. Далее следует описание работы класса.  

*ControllerFlightPlan* (Класс) работает в отдельном потоке. Все публичные методы класса являются асинхронными (вызывающий поток, после вызова метода, продолжает работу без ожидания ответа). Каждый метод, который обращается к БД делает запрос по TCP в  отдельный модуль (процесс) *ControllerFms* (Контроллер) который напрямую взаимодействует с БД и возвращает ответ в *Adapter* (см. схему ниже). 

![Получение данных из БД](/scheme/adapter_fms.png)

После отправки запроса, *Adapter* выполняет некоторое ожидание для получения ответа. Если ответ не получен выполняется повторная отправка запроса (всего 3 попытки). После получения ответа формируется пара: 
```
    std::pair<CommandStatus, Data>
```
которая включает статус выполнения запроса (CommandStatus) и объект данных (Data) полученный из БД. Полученная пара отправляется соответствующим сигналом, например signalResult, и может быть получена при установлении сигнально-слотовой связи соответствующих объектов: 
```
connect(&сontroller, &ControllerFlightPlan::signalResult, manager(), &Manager::slotReceiver)

emit signalResult(pair)
```
Если происходит вызов нескольких подряд методов класса, то все они попадают в очередь на выполнение. Это гарантирует что каждый метод отработает в том порядке в котором был вызван (и вернет ответ сигналом), а затем произойдет обработка следующего в очереди метода. 

**Статус выполнения запросов**

```
    enum class CommandStatus
    {
        OK = 0,
        INVALID,
        NO_CONNECTION,
        ERROR_DATABASE,
    };
``` 
* OK: ошибка при запросе не возникла и данные имеют корректное значение; 
* INVALID: ошибка при запросе не возникла но объект «пустой», то есть не существует в БД или нет корректной информации для расчета объекта. При таком статусе стоит игнорировать поле Data;
* NO_CONNECTION: нет соединения с Контроллером и соответственно с БД. Поле Data должно игнорироваться;
* ERROR_DATABASE: возникла ошибка в БД. Поле Data должно игнорироваться;  

**Пример использования**

```
    // Получение данных для каталога планов

    ControllerFlightPlan controller; 
    QObject::connect(&controller, &ControllerFlightPlan::signalGetCatalogInfoOfPLans, 
    		        [&](const FlightPlanInfoPair &info) { print(info); });
    controller.getCatalogInfoOfPlans();
```
